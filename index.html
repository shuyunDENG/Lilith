<!DOCTYPE html>
<html lang="zh">   
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>systeme_for_interaction_of_alien_creature</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ml5/0.12.2/ml5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            font-family: 'Arial', sans-serif;
            color:white;
        }
        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #status {
            margin: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            text-align: center;
        }
        #controls {
            margin: 10px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;         
        }
        button:hover {
            background: #45a049;
        }
        #memory {
            margin-top: 10px;
            padding: 15px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>🛸 智能外星人互动系统</h1>
        <div id="status">
            <div>状态: <span id="statusText">初始化中...</span></div>
            <div>情绪: <span id="moodText">好奇</span></div>
            <div>学习进度: <span id="learningText">0%</span></div>
        </div>
        <div id="controls">
            <button onclick="resetAlien()">重置外星人</button>
            <button onclick="toggleLearning()">切换学习模式</button>
            <button onclick="showMemory()">显示记忆</button>
        </div>
        <div id="memory" style="display:none;">
            <h3>外星人的记忆库:</h3>
            <div id="memoryContent"></div>
        </div>
    </div>

    <script>
        let video;
        let handpose;
        let predictions = [];
        let alien;
        let isLearning = true;
        let memoryBank = [];
        let canvas;

        // 外星人类
        class Alien {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.size = 60;
                this.mood = 'curious';
                this.energy = 100;
                this.experience = 0;
                this.behaviors = new Map();
                this.lastGesture = null;
                this.adaptationLevel = 0;
                this.wingFlap = 0;
                this.eyeBlinkTimer = 0;
                this.survival = {
                    threat_level: 0,
                    comfort_zone: { x: width/2, y: height/2, radius: 100 },
                    learned_responses: new Map()
                };
            }

            update() {
                // 平滑移动
                this.x = lerp(this.x, this.targetX, 0.05);
                this.y = lerp(this.y, this.targetY, 0.05);
                
                // 翅膀扇动
                this.wingFlap += 0.2;
                
                // 眨眼动画
                this.eyeBlinkTimer += 0.1;
                
                // 根据经验调整行为
                this.adaptBehavior();
                
                // 生存机制更新
                this.updateSurvival();
            }

            adaptBehavior() {
                if (this.experience > 50) {
                    this.adaptationLevel = min(this.adaptationLevel + 0.1, 2);
                }
            }

            updateSurvival() {
                // 计算威胁等级
                let distanceFromCenter = dist(this.x, this.y, width/2, height/2);
                if (distanceFromCenter > 200) {
                    this.survival.threat_level = min(this.survival.threat_level + 0.1, 1);
                } else {
                    this.survival.threat_level = max(this.survival.threat_level - 0.05, 0);
                }
                
                // 根据威胁等级调整行为
                if (this.survival.threat_level > 0.5) {
                    this.mood = 'scared';
                    this.returnToSafeZone();
                }
            }

            returnToSafeZone() {
                this.targetX = this.survival.comfort_zone.x;
                this.targetY = this.survival.comfort_zone.y;
            }

            reactToGesture(gesture) {
                if (!gesture) return;
                
                // 学习和记忆手势
                if (isLearning) {
                    this.learnGesture(gesture);
                }
                
                // 根据学习到的行为做出反应
                this.respondToGesture(gesture);
            }

            learnGesture(gesture) {
                let gestureKey = this.classifyGesture(gesture);
                
                if (!this.behaviors.has(gestureKey)) {
                    this.behaviors.set(gestureKey, {
                        frequency: 1,
                        responses: [],
                        effectiveness: 0.5
                    });
                } else {
                    let behavior = this.behaviors.get(gestureKey);
                    behavior.frequency++;
                    this.behaviors.set(gestureKey, behavior);
                }
                
                this.experience++;
                
                // 保存到记忆库
                memoryBank.push({
                    timestamp: Date.now(),
                    gesture: gestureKey,
                    response: this.mood,
                    effectiveness: this.behaviors.get(gestureKey).effectiveness
                });
                
                // 限制记忆库大小
                if (memoryBank.length > 100) {
                    memoryBank.shift();
                }
            }

            classifyGesture(gesture) {
                // 简化的手势分类
                let hand = gesture.landmarks;
                let thumbTip = hand[4];
                let indexTip = hand[8];
                let middleTip = hand[12];
                
                // 计算手势特征
                let fingersUp = 0;
                if (thumbTip[1] < hand[3][1]) fingersUp++;
                if (indexTip[1] < hand[6][1]) fingersUp++;
                if (middleTip[1] < hand[10][1]) fingersUp++;
                
                if (fingersUp >= 3) return 'open_hand';
                if (fingersUp === 1) return 'pointing';
                if (fingersUp === 0) return 'fist';
                return 'partial';
            }

            respondToGesture(gesture) {
                let gestureType = this.classifyGesture(gesture);
                let hand = gesture.landmarks[0]; // 手腕位置
                
                // 基于学习的反应
                if (this.behaviors.has(gestureType)) {
                    let behavior = this.behaviors.get(gestureType);
                    
                    switch(gestureType) {
                        case 'open_hand':
                            this.mood = 'happy';
                            this.targetX = hand[0] - 50;
                            this.targetY = hand[1] - 100;
                            break;
                        case 'fist':
                            this.mood = 'scared';
                            this.targetX = width - hand[0];
                            this.targetY = height - hand[1];
                            break;
                        case 'pointing':
                            this.mood = 'curious';
                            this.targetX = hand[0];
                            this.targetY = hand[1];
                            break;
                    }
                    
                    // 更新行为效果
                    behavior.effectiveness = min(behavior.effectiveness + 0.1, 1.0);
                } else {
                    // 默认探索性反应
                    this.mood = 'exploring';
                    this.targetX = hand[0] + random(-50, 50);
                    this.targetY = hand[1] + random(-50, 50);
                }
            }

            draw() {
                push();
                translate(this.x, this.y);
                
                // 根据情绪调整颜色
                let alienColor;
                switch(this.mood) {
                    case 'happy': alienColor = color(100, 255, 100); break;
                    case 'scared': alienColor = color(255, 100, 100); break;
                    case 'curious': alienColor = color(100, 255, 255); break;
                    default: alienColor = color(150, 255, 150);
                }
                
                fill(alienColor);
                stroke(0);
                strokeWeight(2);
                
                // 天使翅膀
                fill(255, 255, 255, 180);
                let wingOffset = sin(this.wingFlap) * 10;
                ellipse(-40, -10 + wingOffset, 30, 60);
                ellipse(40, -10 + wingOffset, 30, 60);
                
                // 身体
                fill(alienColor);
                ellipse(0, 0, this.size, this.size * 1.5);
                
                // 头部
                ellipse(0, -this.size * 0.7, this.size * 0.8, this.size);
                
                // 眼睛
                fill(0);
                let eyeBlink = sin(this.eyeBlinkTimer) > 0.9 ? 5 : 15;
                ellipse(-15, -this.size * 0.8, 20, eyeBlink);
                ellipse(15, -this.size * 0.8, 20, eyeBlink);
                
                // 嘴巴 (根据情绪变化)
                strokeWeight(2);
                noFill();
                if (this.mood === 'happy') {
                    arc(0, -this.size * 0.6, 20, 10, 0, PI);
                } else if (this.mood === 'scared') {
                    arc(0, -this.size * 0.5, 15, 10, PI, TWO_PI);
                } else {
                    line(-5, -this.size * 0.55, 5, -this.size * 0.55);
                }
                
                // 四肢
                strokeWeight(3);
                line(0, this.size * 0.3, -20, this.size * 0.8);
                line(0, this.size * 0.3, 20, this.size * 0.8);
                line(-this.size * 0.3, 0, -this.size * 0.6, this.size * 0.4);
                line(this.size * 0.3, 0, this.size * 0.6, this.size * 0.4);
                
                pop();
                
                // 显示学习进度
                this.drawLearningIndicator();
            }

            drawLearningIndicator() {
                if (this.behaviors.size > 0) {
                    push();
                    translate(this.x, this.y - 80);
                    fill(255, 200);
                    textAlign(CENTER);
                    textSize(12);
                    text(`学习: ${this.behaviors.size} 种手势`, 0, 0);
                    pop();
                }
            }
        }

        function setup() {
            canvas = createCanvas(800, 600);
            canvas.parent('container');
            
            // 初始化摄像头
            video = createCapture(VIDEO);
            video.size(320, 240);
            video.hide();
            
            // 初始化手势识别
            handpose = ml5.handpose(video, modelReady);
            handpose.on('predict', results => {
                predictions = results;
            });
            
            // 创建外星人
            alien = new Alien(width/2, height/2);
            
            updateStatus('系统就绪');
        }

        function draw() {
            // 背景
            background(20, 30, 60);
            
            // 绘制星空
            drawStars();
            
            // 显示摄像头画面 (小窗口)
            push();
            translate(width - 170, 10);
            tint(255, 150);
            image(video, 0, 0, 160, 120);
            noTint();
            pop();
            
            // 处理手势
            if (predictions.length > 0) {
                let hand = predictions[0];
                alien.reactToGesture(hand);
                drawHandPoints(hand);
            }
            
            // 更新和绘制外星人
            alien.update();
            alien.draw();
            
            // 更新UI
            updateUI();
        }

        function drawStars() {
            fill(255, 200);
            noStroke();
            for (let i = 0; i < 50; i++) {
                let x = (noise(i * 0.1, frameCount * 0.01) * width);
                let y = (noise(i * 0.2, frameCount * 0.01) * height);
                let size = noise(i * 0.3) * 3;
                ellipse(x, y, size, size);
            }
        }

        function drawHandPoints(hand) {
            stroke(255, 100, 100);
            strokeWeight(3);
            noFill();
            
            // 绘制手的轮廓
            beginShape();
            for (let point of hand.landmarks) {
                vertex(point[0], point[1]);
            }
            endShape();
        }

        function modelReady() {
            updateStatus('手势识别已就绪');
        }

        function updateStatus(text) {
            document.getElementById('statusText').textContent = text;
        }

        function updateUI() {
            document.getElementById('moodText').textContent = alien.mood;
            document.getElementById('learningText').textContent = 
                Math.round((alien.experience / 100) * 100) + '%';
        }

        function resetAlien() {
            alien = new Alien(width/2, height/2);
            memoryBank = [];
            updateStatus('外星人已重置');
        }

        function toggleLearning() {
            isLearning = !isLearning;
            updateStatus(isLearning ? '学习模式开启' : '学习模式关闭');
        }

        function showMemory() {
            let memoryDiv = document.getElementById('memory');
            let contentDiv = document.getElementById('memoryContent');
            
            if (memoryDiv.style.display === 'none') {
                let memoryText = '';
                memoryBank.slice(-10).forEach((memory, i) => {
                    memoryText += `<p>${i+1}. 手势: ${memory.gesture} → 反应: ${memory.response} (效果: ${Math.round(memory.effectiveness * 100)}%)</p>`;
                });
                contentDiv.innerHTML = memoryText || '<p>暂无记忆数据</p>';
                memoryDiv.style.display = 'block';
            } else {
                memoryDiv.style.display = 'none';
            }
        }
    </script>
</body>
</html>


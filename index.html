<!DOCTYPE html>
<html lang="zh">   
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>systeme_for_interaction_of_alien_creature</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ml5/0.12.2/ml5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            font-family: 'Arial', sans-serif;
            color:white;
        }
        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #status {
            margin: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            text-align: center;
        }
        #controls {
            margin: 10px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;         
        }
        button:hover {
            background: #45a049;
        }
        #memory {
            margin-top: 10px;
            padding: 15px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>ğŸ›¸ æ™ºèƒ½å¤–æ˜Ÿäººäº’åŠ¨ç³»ç»Ÿ</h1>
        <div id="status">
            <div>çŠ¶æ€: <span id="statusText">åˆå§‹åŒ–ä¸­...</span></div>
            <div>æƒ…ç»ª: <span id="moodText">å¥½å¥‡</span></div>
            <div>å­¦ä¹ è¿›åº¦: <span id="learningText">0%</span></div>
        </div>
        <div id="controls">
            <button onclick="resetAlien()">é‡ç½®å¤–æ˜Ÿäºº</button>
            <button onclick="toggleLearning()">åˆ‡æ¢å­¦ä¹ æ¨¡å¼</button>
            <button onclick="showMemory()">æ˜¾ç¤ºè®°å¿†</button>
        </div>
        <div id="memory" style="display:none;">
            <h3>å¤–æ˜Ÿäººçš„è®°å¿†åº“:</h3>
            <div id="memoryContent"></div>
        </div>
    </div>

    <script>
        let video;
        let handpose;
        let predictions = [];
        let alien;
        let isLearning = true;
        let memoryBank = [];
        let canvas;

        // å¤–æ˜Ÿäººç±»
        class Alien {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.size = 60;
                this.mood = 'curious';
                this.energy = 100;
                this.experience = 0;
                this.behaviors = new Map();
                this.lastGesture = null;
                this.adaptationLevel = 0;
                this.wingFlap = 0;
                this.eyeBlinkTimer = 0;
                this.survival = {
                    threat_level: 0,
                    comfort_zone: { x: width/2, y: height/2, radius: 100 },
                    learned_responses: new Map()
                };
            }

            update() {
                // å¹³æ»‘ç§»åŠ¨
                this.x = lerp(this.x, this.targetX, 0.05);
                this.y = lerp(this.y, this.targetY, 0.05);
                
                // ç¿…è†€æ‰‡åŠ¨
                this.wingFlap += 0.2;
                
                // çœ¨çœ¼åŠ¨ç”»
                this.eyeBlinkTimer += 0.1;
                
                // æ ¹æ®ç»éªŒè°ƒæ•´è¡Œä¸º
                this.adaptBehavior();
                
                // ç”Ÿå­˜æœºåˆ¶æ›´æ–°
                this.updateSurvival();
            }

            adaptBehavior() {
                if (this.experience > 50) {
                    this.adaptationLevel = min(this.adaptationLevel + 0.1, 2);
                }
            }

            updateSurvival() {
                // è®¡ç®—å¨èƒç­‰çº§
                let distanceFromCenter = dist(this.x, this.y, width/2, height/2);
                if (distanceFromCenter > 200) {
                    this.survival.threat_level = min(this.survival.threat_level + 0.1, 1);
                } else {
                    this.survival.threat_level = max(this.survival.threat_level - 0.05, 0);
                }
                
                // æ ¹æ®å¨èƒç­‰çº§è°ƒæ•´è¡Œä¸º
                if (this.survival.threat_level > 0.5) {
                    this.mood = 'scared';
                    this.returnToSafeZone();
                }
            }

            returnToSafeZone() {
                this.targetX = this.survival.comfort_zone.x;
                this.targetY = this.survival.comfort_zone.y;
            }

            reactToGesture(gesture) {
                if (!gesture) return;
                
                // å­¦ä¹ å’Œè®°å¿†æ‰‹åŠ¿
                if (isLearning) {
                    this.learnGesture(gesture);
                }
                
                // æ ¹æ®å­¦ä¹ åˆ°çš„è¡Œä¸ºåšå‡ºååº”
                this.respondToGesture(gesture);
            }

            learnGesture(gesture) {
                let gestureKey = this.classifyGesture(gesture);
                
                if (!this.behaviors.has(gestureKey)) {
                    this.behaviors.set(gestureKey, {
                        frequency: 1,
                        responses: [],
                        effectiveness: 0.5
                    });
                } else {
                    let behavior = this.behaviors.get(gestureKey);
                    behavior.frequency++;
                    this.behaviors.set(gestureKey, behavior);
                }
                
                this.experience++;
                
                // ä¿å­˜åˆ°è®°å¿†åº“
                memoryBank.push({
                    timestamp: Date.now(),
                    gesture: gestureKey,
                    response: this.mood,
                    effectiveness: this.behaviors.get(gestureKey).effectiveness
                });
                
                // é™åˆ¶è®°å¿†åº“å¤§å°
                if (memoryBank.length > 100) {
                    memoryBank.shift();
                }
            }

            classifyGesture(gesture) {
                // ç®€åŒ–çš„æ‰‹åŠ¿åˆ†ç±»
                let hand = gesture.landmarks;
                let thumbTip = hand[4];
                let indexTip = hand[8];
                let middleTip = hand[12];
                
                // è®¡ç®—æ‰‹åŠ¿ç‰¹å¾
                let fingersUp = 0;
                if (thumbTip[1] < hand[3][1]) fingersUp++;
                if (indexTip[1] < hand[6][1]) fingersUp++;
                if (middleTip[1] < hand[10][1]) fingersUp++;
                
                if (fingersUp >= 3) return 'open_hand';
                if (fingersUp === 1) return 'pointing';
                if (fingersUp === 0) return 'fist';
                return 'partial';
            }

            respondToGesture(gesture) {
                let gestureType = this.classifyGesture(gesture);
                let hand = gesture.landmarks[0]; // æ‰‹è…•ä½ç½®
                
                // åŸºäºå­¦ä¹ çš„ååº”
                if (this.behaviors.has(gestureType)) {
                    let behavior = this.behaviors.get(gestureType);
                    
                    switch(gestureType) {
                        case 'open_hand':
                            this.mood = 'happy';
                            this.targetX = hand[0] - 50;
                            this.targetY = hand[1] - 100;
                            break;
                        case 'fist':
                            this.mood = 'scared';
                            this.targetX = width - hand[0];
                            this.targetY = height - hand[1];
                            break;
                        case 'pointing':
                            this.mood = 'curious';
                            this.targetX = hand[0];
                            this.targetY = hand[1];
                            break;
                    }
                    
                    // æ›´æ–°è¡Œä¸ºæ•ˆæœ
                    behavior.effectiveness = min(behavior.effectiveness + 0.1, 1.0);
                } else {
                    // é»˜è®¤æ¢ç´¢æ€§ååº”
                    this.mood = 'exploring';
                    this.targetX = hand[0] + random(-50, 50);
                    this.targetY = hand[1] + random(-50, 50);
                }
            }

            draw() {
                push();
                translate(this.x, this.y);
                
                // æ ¹æ®æƒ…ç»ªè°ƒæ•´é¢œè‰²
                let alienColor;
                switch(this.mood) {
                    case 'happy': alienColor = color(100, 255, 100); break;
                    case 'scared': alienColor = color(255, 100, 100); break;
                    case 'curious': alienColor = color(100, 255, 255); break;
                    default: alienColor = color(150, 255, 150);
                }
                
                fill(alienColor);
                stroke(0);
                strokeWeight(2);
                
                // å¤©ä½¿ç¿…è†€
                fill(255, 255, 255, 180);
                let wingOffset = sin(this.wingFlap) * 10;
                ellipse(-40, -10 + wingOffset, 30, 60);
                ellipse(40, -10 + wingOffset, 30, 60);
                
                // èº«ä½“
                fill(alienColor);
                ellipse(0, 0, this.size, this.size * 1.5);
                
                // å¤´éƒ¨
                ellipse(0, -this.size * 0.7, this.size * 0.8, this.size);
                
                // çœ¼ç›
                fill(0);
                let eyeBlink = sin(this.eyeBlinkTimer) > 0.9 ? 5 : 15;
                ellipse(-15, -this.size * 0.8, 20, eyeBlink);
                ellipse(15, -this.size * 0.8, 20, eyeBlink);
                
                // å˜´å·´ (æ ¹æ®æƒ…ç»ªå˜åŒ–)
                strokeWeight(2);
                noFill();
                if (this.mood === 'happy') {
                    arc(0, -this.size * 0.6, 20, 10, 0, PI);
                } else if (this.mood === 'scared') {
                    arc(0, -this.size * 0.5, 15, 10, PI, TWO_PI);
                } else {
                    line(-5, -this.size * 0.55, 5, -this.size * 0.55);
                }
                
                // å››è‚¢
                strokeWeight(3);
                line(0, this.size * 0.3, -20, this.size * 0.8);
                line(0, this.size * 0.3, 20, this.size * 0.8);
                line(-this.size * 0.3, 0, -this.size * 0.6, this.size * 0.4);
                line(this.size * 0.3, 0, this.size * 0.6, this.size * 0.4);
                
                pop();
                
                // æ˜¾ç¤ºå­¦ä¹ è¿›åº¦
                this.drawLearningIndicator();
            }

            drawLearningIndicator() {
                if (this.behaviors.size > 0) {
                    push();
                    translate(this.x, this.y - 80);
                    fill(255, 200);
                    textAlign(CENTER);
                    textSize(12);
                    text(`å­¦ä¹ : ${this.behaviors.size} ç§æ‰‹åŠ¿`, 0, 0);
                    pop();
                }
            }
        }

        function setup() {
            canvas = createCanvas(800, 600);
            canvas.parent('container');
            
            // åˆå§‹åŒ–æ‘„åƒå¤´
            video = createCapture(VIDEO);
            video.size(320, 240);
            video.hide();
            
            // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«
            handpose = ml5.handpose(video, modelReady);
            handpose.on('predict', results => {
                predictions = results;
            });
            
            // åˆ›å»ºå¤–æ˜Ÿäºº
            alien = new Alien(width/2, height/2);
            
            updateStatus('ç³»ç»Ÿå°±ç»ª');
        }

        function draw() {
            // èƒŒæ™¯
            background(20, 30, 60);
            
            // ç»˜åˆ¶æ˜Ÿç©º
            drawStars();
            
            // æ˜¾ç¤ºæ‘„åƒå¤´ç”»é¢ (å°çª—å£)
            push();
            translate(width - 170, 10);
            tint(255, 150);
            image(video, 0, 0, 160, 120);
            noTint();
            pop();
            
            // å¤„ç†æ‰‹åŠ¿
            if (predictions.length > 0) {
                let hand = predictions[0];
                alien.reactToGesture(hand);
                drawHandPoints(hand);
            }
            
            // æ›´æ–°å’Œç»˜åˆ¶å¤–æ˜Ÿäºº
            alien.update();
            alien.draw();
            
            // æ›´æ–°UI
            updateUI();
        }

        function drawStars() {
            fill(255, 200);
            noStroke();
            for (let i = 0; i < 50; i++) {
                let x = (noise(i * 0.1, frameCount * 0.01) * width);
                let y = (noise(i * 0.2, frameCount * 0.01) * height);
                let size = noise(i * 0.3) * 3;
                ellipse(x, y, size, size);
            }
        }

        function drawHandPoints(hand) {
            stroke(255, 100, 100);
            strokeWeight(3);
            noFill();
            
            // ç»˜åˆ¶æ‰‹çš„è½®å»“
            beginShape();
            for (let point of hand.landmarks) {
                vertex(point[0], point[1]);
            }
            endShape();
        }

        function modelReady() {
            updateStatus('æ‰‹åŠ¿è¯†åˆ«å·²å°±ç»ª');
        }

        function updateStatus(text) {
            document.getElementById('statusText').textContent = text;
        }

        function updateUI() {
            document.getElementById('moodText').textContent = alien.mood;
            document.getElementById('learningText').textContent = 
                Math.round((alien.experience / 100) * 100) + '%';
        }

        function resetAlien() {
            alien = new Alien(width/2, height/2);
            memoryBank = [];
            updateStatus('å¤–æ˜Ÿäººå·²é‡ç½®');
        }

        function toggleLearning() {
            isLearning = !isLearning;
            updateStatus(isLearning ? 'å­¦ä¹ æ¨¡å¼å¼€å¯' : 'å­¦ä¹ æ¨¡å¼å…³é—­');
        }

        function showMemory() {
            let memoryDiv = document.getElementById('memory');
            let contentDiv = document.getElementById('memoryContent');
            
            if (memoryDiv.style.display === 'none') {
                let memoryText = '';
                memoryBank.slice(-10).forEach((memory, i) => {
                    memoryText += `<p>${i+1}. æ‰‹åŠ¿: ${memory.gesture} â†’ ååº”: ${memory.response} (æ•ˆæœ: ${Math.round(memory.effectiveness * 100)}%)</p>`;
                });
                contentDiv.innerHTML = memoryText || '<p>æš‚æ— è®°å¿†æ•°æ®</p>';
                memoryDiv.style.display = 'block';
            } else {
                memoryDiv.style.display = 'none';
            }
        }
    </script>
</body>
</html>

